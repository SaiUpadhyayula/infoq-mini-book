[[chapter-4]]
= Building REST API using Spring Boot
:toc:

Let's go ahead and start developing our Expense Tracker REST API.

We will start by creating the domain model of our Expense Tracker Application.

== Domain Model

An Expense Tracker Application can have the following domain classes:

* Expense
* ExpenseCategory
* User

Here is how we can model the `Expense.java` class:

[source,java]
----
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Expense {
    private String id;
    private String expenseName;
    private ExpenseCategory expenseCategory;
    private BigDecimal expenseAmount;
}
----

This is a simple Plain Old Java Object (POJO) class, but with a twist, you can observe that we don't have usual blocks of Java code like No-Args and Argument Constructor, Getter/Setter, etc.

These are all generated at compile-time using the library we added in chapter-2 called as `lombok` which will help us by generating the Java Boiler Plate code.

You can observe the annotations `@Getter`, `@Setter`, `@AllArgsConstructor`, `@NoArgsConstructor` they are pretty self-explanatory.

`@Builder` annotation generates the necessary code to implement the `Builder` design pattern. You can learn more about `Builder Design Pattern` here - https://refactoring.guru/design-patterns/builder

The `Expense.java` class defines a field of type `ExpenseCategory` which is a Java Enum that looks like below:

[source,java]
----
public enum ExpenseCategory {
    ENTERTAINMENT, GROCERIES, RESTAURANT, UTILITIES, MISC
}
----

Finally, we have the `User.java` class which looks like below:

[source, java]
----
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class User {
    private String id;
    private String userName;
    private String password;
    private String email;
}
----

After defining the domain model, we can now start creating the REST Endpoints.

== Installing MongoDB

As mentioned we will be using MongoDB as our database, you can install MongoDB either by using Docker (or) manually.

You can find the resources to download and install MongoDB Community Edition here - https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-windows/

== Configuring MongoDB in Expense Tracker Application

After installing MongoDB, the next step is to configure our Expense Tracker Application with MongoDB.

We can do that by adding the following properties to the `application.properties` (or) `application.yml` file.

[source, properties]
----
spring.data.mongodb.uri=mongodb://localhost:27017/expense-tracker
----

The `spring.data.mongodb.uri` contains all the necessary information required to configure the MongoDB in our application.

NOTE: MongoDB by default runs on port - 27017, if you chose to install it in different port, make sure to use the same port in the URI.


== Creating Repositories using Spring Data

The next step is to create the logic to define the classes which are responsible to store the information in the MongoDB.

Spring Boot has a project called as `Spring Data`, that abstracts away the logic to write the usual database operations code.

It implements the famous Repository Pattern, which you can learn more about in this article - https://martinfowler.com/eaaCatalog/repository.html

By using `Spring Data` all you have to do is create an interface called as `ExpenseRepository.java` and extend the interface with `MongoRepository.java`.

This is how the code for `ExpenseRepository.java` looks like:

[source, java]
----
package com.programming.techie.expensetracker.repository;

import com.programming.techie.expensetracker.model.Expense;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import java.util.Optional;


public interface ExpenseRepository extends MongoRepository<Expense, String> {
}

----

We have an interface called `ExpenseRepository` which extends the `MongoRepository.java` interface which brings in a lot of functionality to our `ExpenseRepository.java`

Now let's learn a bit more about the `MongoRepository` interface.

[source,java]
----
package org.springframework.data.mongodb.repository;

import java.util.List;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Sort;
import org.springframework.data.repository.ListCrudRepository;
import org.springframework.data.repository.ListPagingAndSortingRepository;
import org.springframework.data.repository.NoRepositoryBean;
import org.springframework.data.repository.query.QueryByExampleExecutor;

@NoRepositoryBean
public interface MongoRepository<T, ID> extends ListCrudRepository<T, ID>, ListPagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T> {
    <S extends T> S insert(S entity);

    <S extends T> List<S> insert(Iterable<S> entities);

    <S extends T> List<S> findAll(Example<S> example);

    <S extends T> List<S> findAll(Example<S> example, Sort sort);
}

----

The `ExpenseRepository` interface inherits all the above-mentioned methods you see in the `MongoRepository.java` class, and `Spring Data` will provide implementations to this method at run-time.

So you need not worry about opening a Database connection, writing the logic to perform necessary database operations and finally closing the Database Connection. Everything is handled for us by `Spring Data`. Pretty cool, right ?

The next step is to map our Domain Model classes to the Database, we can do that by adding the `@Document` annotation on top of our `Expense.java` class, as we are going to store the expense in the database.

NOTE: In the traditional Relational Databses, we usually store the data inside the tables. In MongoDB, we do not use Tables, but store them in the form of Documents. That's why we have the `@Document` annotation to represent our Expense class as a MongoDB document.

Here is how the `Expense.java` class looks like after adding the necessary annotations:

[source,java]
----
package com.programming.techie.expensetracker.model;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.math.BigDecimal;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Document("expense") <1>
public class Expense {
    @Id <2>
    private String id;
    @Field("name") <3>
    @Indexed(unique = true) <4>
    private String expenseName;
    @Field("category")
    private ExpenseCategory expenseCategory;
    @Field("amount")
    private BigDecimal expenseAmount;
}

----

<1> As mentioned in the NOTE section above, we add the `@Document` to denote the `Expense` object as a MongoDB Document.
<2> We define a primary key in our document, by using the `@Id` annotation, notice that the ID created by MongoDB is in the form of Binary Object Notation, you can read more about it here - https://www.mongodb.com/basics/bson
<3> We can map each field inside our `Expense` class into the Mongodb document, with the help of the `@Field` annotation. For example, you can have the expense saved with fieldname - "category" instead of "expenseCategory".

Alright, now we have the logic to store the expenses, but how do we receive the expenses from the clients into our application ? Who is responsible for this ? The answer is Controllers, let's create them in the next section.

== Creating Controllers

To start building the REST Endpoints, you need to get familiarized with the term called as `Controller`.

Before that let's revisit the MVC Design Pattern

[source]
----

                                         ___________________
                                        |                   |
                                        |        Model      | <2>
                                         ___________________
                                      /
                                     /
                 ___________________/
                |                   |
                |   Controller      | <1>
                 ___________________
                                     \
                                      \
                                       \
                                         ___________________
                                        |                   |
                                        |        View       | <3>
                                         ___________________
----

In the MVC Pattern, we have the main components - Model, View and Controllers.

<1> The Controller is responsible to accept the requests coming from the external client and forwarding it to the application service layer.

<2> The Model contains the information which is exposed by the webservice/application.

<3> The View contains the response usually returned as response by the Controller. In a traditional web application, this can be an HTML page, but in RESTful applications, this can be just a JSON/XML payload as response.

=== @RestController

Spring Boot provides the functionality of the Controller in the MVC Design Pattern using the `@Controller` annotation, if you want to handle RESTful applications, then it has another annotation called `@RestController` which is nothing but a wrapper around the `@Controller` annotaion.

By adding this annotation, Spring Boot will start listening to incoming requests to the application, and will start responding in the form of either JSON/XML.

Let's create a class called as `ExpenseController.java`

[source,java]
----
package com.programming.techie.expensetracker.web;

import com.programming.techie.expensetracker.dto.ExpenseDto;
import com.programming.techie.expensetracker.exception.ExpenseNotFoundException;
import com.programming.techie.expensetracker.model.Expense;
import com.programming.techie.expensetracker.service.ExpenseService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController <1>
@RequestMapping("/api/expense")
@RequiredArgsConstructor
public class ExpenseController {

    private final ExpenseService expenseService;

    @PostMapping <2>
    public ResponseEntity<Void> addExpense(@RequestBody ExpenseDto expenseDto) {
        String expenseId = expenseService.addExpense(expenseDto);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(expenseId)
                .toUri();
        return ResponseEntity.created(location)
                .build(); <3>
    }

    @PutMapping <5>
    @ResponseStatus(HttpStatus.OK)
    public void updateExpense(@RequestBody ExpenseDto expense) {
        expenseService.updateExpense(expense);
    }

    @GetMapping <4>
    @ResponseStatus(HttpStatus.OK)
    public List<ExpenseDto> getAllExpenses() {
        return expenseService.getAllExpenses();
    }

    @GetMapping("/{id}") <6>
    @ResponseStatus(HttpStatus.OK)
    public ExpenseDto getExpense(@PathVariable String id) {
        return expenseService.getExpense(id);
    }

    @DeleteMapping("/{id}") <7>
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteExpense(@PathVariable String id) {
        expenseService.deleteExpense(id);
    }

}

----

<1> We annotate our class with `@RestController` and `@RequestMapping` annotations, so our `ExpenseController` can listen to the incoming requests starting with the path - `/api/expense`.

<2> We can use the `@PostMapping` annotation to define the addExpense method as a POST Endpoint. You can also observe that we are using a `@RequestBody` annotation to denote that we are expecting a Body inside the HTTP Post Request. When the `@RequestBody` annotation is present, Spring Boot will automatically parse the incoming HTTP Request Body to the ExpenseDto object.

<3> Inside the addExpense Method, we are processing the request, by passing the `expenseDto` object to the `addExpense` method of the `ExpenseService.java` class, after that we are creating a URI with the expenseId as the path-variable, and sending that URI as part of the `Location` header in the response. This is the standard way of implementing a response in RESTful applications, whenever you are creating a Resource.

<4> We have the `@GetMapping` annotation to map the `getAllExpenses` which returns all the expenses we have in our application. Please note that we can use the `@ResponseStatus` annotation to define the HTTP Response Status we need to send back to the client.

<5> We have the `@PutMapping` annotation which listens for HTTP PUT requests and executes the method `updateExpense` in the `ExpenseService` class.

<6> We also have another `@GetMapping` annotation mapped to the `getExpenseByName` method, which as the name suggests retrieves a given expense by its name. Spring Boot provides the `@PathVariable` annotation to read the `name` from the URI and map it to the String variable.

<7> Finally, we have a `@DeleteMapping` annotation mapped to the `deleteExpense` method, which takes in the `id` of the given expense which is again parsed using the `@PathVariable` annotation and passed to the `deleteExpense` method of the `ExpenseService`.

NOTE: You can observe that we are using `@RequiredArgsConstructor` annotation which will generate the constructor at compile time with all the required arguments.

Let's see how the `ExpenseDto.java` object looks like:

[source,java]
----
package com.programming.techie.expensetracker.dto;

import com.programming.techie.expensetracker.model.ExpenseCategory;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ExpenseDto {
    private String id;
    private String expenseName;
    private ExpenseCategory expenseCategory;
    private BigDecimal expenseAmount;
}

----

`ExpenseDto.java` acts as a Data Transfer Object (DTO), whose responsibility is to transfer the data between the client and the server.

.Why note use Expense class instead of ExpenseDto ?
****
You may ask why we have to create a seperate class called `ExpenseDto` to model the Request Body, when we are using almost same fields as `Expense`. Why not use `Expense` object itself ?

That's a very valid question.

There are 2 main reasons for using a Data Transfer Object:

1. It's usually not advisable to expose your domain model to the external world, as it usually contains a lot of information which is not relevant to the clients.
2. APIs evolve overtime and needs to handle different kinds of data which are not part of the Domain Model. For example, in the future we may want to add a different field in the Request Body, but we don't need to store it in the database. In that case, we can just add the field to the `ExpenseDto` and need not touch the `Expense` object.
****

=== Creating ExpenseService

Now let's also create a class called `ExpenseService.java` which is responsible to handle the actual business logic to perform CRUD operations for the Expense :

[source, java]
----
package com.programming.techie.expensetracker.service;

import com.programming.techie.expensetracker.dto.ExpenseDto;
import com.programming.techie.expensetracker.exception.ExpenseNotFoundException;
import com.programming.techie.expensetracker.model.Expense;
import com.programming.techie.expensetracker.repository.ExpenseRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.stream.Collectors;

@Service <1>
@RequiredArgsConstructor
public class ExpenseService {

    private final ExpenseRepository expenseRepository;

    public String addExpense(ExpenseDto expenseDto) { <2>
        Expense expense = mapFromDto(expenseDto);
        return expenseRepository.insert(expense).getId();
    }

    public void updateExpense(ExpenseDto expenseDto) { <3>
        Expense expense = mapFromDto(expenseDto);
        Expense savedExpense = expenseRepository.findById(expenseDto.getId()).orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST,
                String.format("Cannot Find Expense by ID %s", expense.getId())));
        savedExpense.setExpenseName(expense.getExpenseName());
        savedExpense.setExpenseCategory(expense.getExpenseCategory());
        savedExpense.setExpenseAmount(expense.getExpenseAmount());

        expenseRepository.save(savedExpense);
    }

    public ExpenseDto getExpense(String id) { <4>
        Expense expense = expenseRepository.findById(id)
                .orElseThrow(() -> new ExpenseNotFoundException(String.format("Cannot Find Expense by ID - %s", id)));
        return mapToDto(expense);
    }

    public List<ExpenseDto> getAllExpenses() { <5>
        return expenseRepository.findAll()
                .stream()
                .map(this::mapToDto).collect(Collectors.toList());
    }

    public void deleteExpense(String id) { <6>
        expenseRepository.deleteById(id);
    }

    private ExpenseDto mapToDto(Expense expense) {
        return ExpenseDto.builder()
                .id(expense.getId())
                .expenseName(expense.getExpenseName())
                .expenseCategory(expense.getExpenseCategory())
                .expenseAmount(expense.getExpenseAmount())
                .build();
    }

    private Expense mapFromDto(ExpenseDto expense) {
        return Expense.builder()
                .expenseName(expense.getExpenseName())
                .expenseCategory(expense.getExpenseCategory())
                .expenseAmount(expense.getExpenseAmount())
                .build();
    }
}

----

<1> The `ExpenseService` class is annotated with `@Service` annotation which denotes that this class is supposed to be a Service, Spring Boot will then create an object (Bean) for this class during the application start-up.
<2> The `addExpense` method takes an `ExpenseDto` class and maps the `ExpenseDto` object to an `Expense` object, which is passed to the `insert` method of the `ExpenseRepository` Spring Data Repository Interface.
<3> We have the `updateExpense` which takes in an `ExpenseDto` object similar to `addExpense`, maps it to `Expense` object and saves the updated `Expense` object back to the database using the `ExpenseRepository.save()` method.
<4> Next, we have the `getExpense` method which retrieves the `Expense` based on the id, using the `findById` method in the `ExpenseRepository`, inherited from the `MongoRepository` method. If the expense is not found with a given id, we throw an `ExpenseNotFoundException`
<5> The `getAllExpenses` method, retrieves all the expenses present in our database and maps the response to `ExpenseDto` objects, before returning it back in the form of a `List`.
<6> Lastly, we have the `deleteExpense` method which takes in an `id` of the `Expense` object, and deletes the `Expense`.

WARNING: Use findAll() method judiciously in your production apps, this will read all the documents in the database, if you are dealing with a pretty big database, then your database will take a lot of time to retrieve all the records.

Lastly, here is how our `ExpenseNotFoundException` class looks like:

[source,java]
----
package com.programming.techie.expensetracker.exception;

public class ExpenseNotFoundException extends RuntimeException {
    public ExpenseNotFoundException(String message) {
        super(message);
    }
}

----

== Implement Validation for our REST API

So we built the basic REST API, but we can improve this API by adding input validation.

As of now, we can send all kinds of invaild input to our REST API.

Input Validation is very essential to make sure you don't have invalid data in your database.

In Chapter-2, we added the validation starter which adds the validation capabilities to our Spring Boot REST API.

Here are some validation rules we are going to implement:

* Expense ID Should not be null/empty, and it should only accept alphanumeric characters.
* Expense Name should not be null/empty, and it should only accept alphabets from a-z and A-Z.
* Expense Amount should accept only a minimum value of 0.

We have several annotations which will communicate our intent for validation. Eg:

* @NotNull as the name suggest makes sure that the value is Not Null
* @NotEmpty makes sure that the value is Not Empty.
* @NotBlank makes sure that the value is Not Empty and Not Null.
* Similar, we have @Pattern annotation which takes in Regular expression to validate the input.
* Finally, we have the @Min annotation, which makes sure that the provided value falls above the minimum range.

Our `ExpenseDto.java` class looks like below, after adding the necessary annotations for the validation.

[source, java]
----
package com.programming.techie.expensetracker.dto;

import com.programming.techie.expensetracker.model.ExpenseCategory;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ExpenseDto {
    @NotBlank
    @Pattern(regexp = "[A-Za-z0-9]+")
    private String id;
    @NotBlank
    @Pattern(regexp = "[a-zA-Z]")
    private String expenseName;
    private ExpenseCategory expenseCategory;
    @Min(value = 0)
    private BigDecimal expenseAmount;
}

----

== Perform Manual Tests on our API

So we finished the basic implementation of our REST API, now let's go ahead and start the `ExpenseTrackerApplication` and test out our API using an HTTP Client.

You can use any HTTP Client to perform tests, I am using https://www.postman.com/[Postman], but you can use any HTTP Client you like.

To run the application, type the below command, or start the `ExpenseTrackerApplication` class in your favourite IDE.

If you are using Linux/macOS
[source, bash]
----
./mvnw spring-boot:run
----

If you are using Windows
[source, shell]
----
./mvnw.cmd spring-boot:run
----

=== Testing `POST` Requests

As we don't have any existing data in our application, let's start our test by creating some expenses.

I am going to send a `POST` request with the below Request Body:

[source, json]
----
{
    "expenseName": "Movies with friends",
    "expenseCategory": "ENTERTAINMENT",
    "expenseAmount": 100
}
----

to the URL: `http:localhost:8080/api/expense`

This request should return an empty response body with HTTP Status as `201 Created`, you should also observe that in the `Location` header we can also see the URL to access the created `Expense`.

image::Manual_Test_POST.png[Manual Test for POST call]

=== Testing `GET` Requests

So now let's test the GET requests by calling the two available endpoints:

* The Get All Expenses Endpoint
* The Get Expense Endpoint which takes in the Expense Id as path variable.

==== Testing Get All Expense Endpoint

Let's make a HTTP GET request to the URL - http://localhost:8080/api/expense

It should return the `Expense` we created before.

You can also create some other expenses using the above `POST` endpoint to test, whether the endpoint is indeed returning all `Expense` objects or not.

==== Testing Get Expense Endpoint

For this, we already have the URL, from the `Location` header when we made the `POST` request, just copy the URL and paste it in your HTTP Client.

You should see be able to see the given expense.

=== Testing `PUT` Request

Now let's try to update the name of the expense from "Movies with Friends" to "Concert with Friends", as we are making a `PUT` request, we have to send the whole Request Body again, to make sure that only `expenseName` attribute is updated.

[source,json]
----
{
    "expenseName": "Concert with Friends",
    "expenseCategory": "ENTERTAINMENT",
    "expenseAmount": 100
}
----

You should see an empty response with HTTP Status as `200 OK`

Let's access the Get Expense Endpoint again and verify if we see the updated `Expense` name (or) not.

image::Manual_Test_PUT_And_Get.png[Testing PUT Request]

As you can see, the `expenseName` attribute is updated successfully.

=== Testing `DELETE` Request

Now let's go ahead and test the last and final endpoint - to delete an `Expense`.

We are going to make a request to the http://localhost:8080/api/expense/<your-expense-id>[http://localhost:8080/api/expense/<your-expense-id>]

And you should receive an empty response with HTTP Status as `204-No Content`

You can also verify if the delete operation worked correctly (or) not by querying the Get Expense Endpoint (or) Get All Expenses Endpoint.

== Summary

In this chapter, we covered a lot, starting with creating our Domain Model, installing and configuring MongoDB in our application, creating Repository, Service and Controller classes to manage our Expense objects.

Finally, we also performed some manual tests using `Postman`.

But we still don't have Automated tests in our application, in the next chapter, we will learn how to write Automated Unit and Integration Tests for our Expense Tracker API.

