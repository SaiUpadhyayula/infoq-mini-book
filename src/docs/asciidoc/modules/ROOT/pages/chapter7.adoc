[[chapter-7]]
= Exception Handling in REST APIs

In this chapter, you will learn how to handle exceptions thrown by our ExpenseTracker application.

In the `ExpensService` class, inside the `getExpense` method, we are reading the expense from the database by id, and if there is no expense with the given id, then we are throwing an `ExpenseNotFoundException`.

This is how it looks like when you make a call to the Get Expense Endpoint - /api/expense/{expenseId} with invalid `expenseId`:

[source,json]
----
{
"timestamp": "2023-01-27T18:02:22.324+00:00",
"status": 500,
"error": "Internal Server Error",
"path": "/api/expense/1cda56104f99f6043cc7db8"
}
----

The above error is fine, but in the real-world you may want to add much more details when an exception is raised in your application.

For example:

* You may want to see the exception message as part of the response.
* You may want to add a custom exception handling URL, so that the client can redirect to that particular URL.
* Categorize the Exception into different formats like: Generic, Technical exceptions.

Spring Boot 3 includes a library from Zalando called problem-spring-web, and provides the functionality using the `ProblemDetail` class.

== Define Handlers using @ExceptionHandler annotation

We can define an Exception Handler for the `ExpenseNotFoundException` by first defining a class called `ExpenseExceptionHandler` that has the `@ControllerAdvice` annotation and extends the `ResponseEntityExceptionHandler` class.

The `@ControllerAdvice` annotation is used to execute a common code whenever an event occurs inside our Controllers.

As we are dealing with creating custom responses by handling the exceptions thrown by our Expense Tracker application, we are extending the class - `ResponseEntityExceptionHandler`.

The complete code for the `ExpenseExceptionHandler` can be found below:

[source, java]
----
package com.programming.techie.expensetracker.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.net.URI;
import java.time.Instant;

@ControllerAdvice
public class ExpenseExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(ExpenseNotFoundException.class)
    ProblemDetail handleExpenseNotFoundException(ExpenseNotFoundException e) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, e.getMessage());
        problemDetail.setTitle("Expense Not Found");
        problemDetail.setType(URI.create("https://api.expenses.com/errors/not-found"));
        problemDetail.setProperty("errorCategory", "Generic");
        problemDetail.setProperty("timestamp", Instant.now());
        return problemDetail;
    }
}
----

Here inside the `handleExpenseNotFoundException` method, we added the `@ExceptionHandler` annotation on top of the method and inside the method, we created an object of `ProblemDetail` class, and we are providing the necessary details like `title`, `type`, and some custom properties like `errorCategory`, `timestamp`, etc. We are also setting the HTTP Status as 404 (NOT_FOUND).

After adding this class, if you re-start the application and call the Get Expense Endpoint, with an invalid `expenseId` you should see the below Error response:

[source, json]
----
{
    "type": "https://api.expenses.com/errors/not-found",
    "title": "Expense Not Found",
    "status": 404,
    "detail": "Cannot Find Expense by ID - 1cda56104f99f6043cc7db8",
    "instance": "/api/expense/1cda56104f99f6043cc7db8",
    "errorCategory": "Generic",
    "timestamp": "2023-01-27T18:10:48.347319800Z"
}
----

You can observe that this response is much more clear than the default error response generated by Spring Boot.

You can customize this `ProblemDetail` object and add any information you feel is necessary for your APIs.

== Adapting our tests to handle the Exceptions

As we made some changes in our exception handling logic, now let's go ahead and write a test to verify that the exception handling behavior.

Inside the `ExpenseController.java`, add the below test method:

[source,java]
----
@WebMvcTest(controllers = ExpenseController.class)
class ExpenseControllerTest {

    ...
    ...

    @Test
    @DisplayName("Should Return 404 Not Found Exception when calling expense endpoint with invalid id")
    void shouldReturn404ErrorResponseForGETWithInvalidId() throws Exception {
        Mockito.when(expenseService.getExpense("123")).thenThrow(new ExpenseNotFoundException("Cannot find Expense By id - 123")); <1>

        MvcResult mvcResult = mockMvc.perform(get("/api/expense/123") <2>
                        .contentType(MediaType.APPLICATION_JSON_VALUE))
                .andExpect(MockMvcResultMatchers.status().isNotFound())
                .andExpect(MockMvcResultMatchers.jsonPath("$.type").value("https://api.expenses.com/errors/not-found"))
                .andExpect(MockMvcResultMatchers.jsonPath("$.title").value("Expense Not Found"))
                .andExpect(MockMvcResultMatchers.jsonPath("$.errorCategory").value("Generic"))
                .andReturn();

    }
}

----

<1> Inside the test, you can observe that we are simulating the error using Mockito, by making sure that our `expenseService.getExpense()` method throws an `ExpenseNotFoundException`
<2> Now using the `mockMvc.perform()` method we are making a GET call to the `/api/expense/123` endpoint, and first verifying that the response status is Not Found, later we are verifying the fields we added inside the `ExpenseExceptionHandler` class like `title`, `type`, `errorCategory`, etc.

== Summary

In this final chapter, you learned how to handle custom exceptions in your Spring Boot REST APIs.
